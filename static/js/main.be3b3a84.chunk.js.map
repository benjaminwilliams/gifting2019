{"version":3,"sources":["utils/encrypt.ts","generate/generate.ts","generate/index.tsx","decode/decode.tsx","App.tsx","serviceWorker.js","index.js"],"names":["encrypt","text","key","CryptoJS","AES","toString","generate","people","doEncode","removeCurrentPerson","person","allPeople","slice","personPosition","findIndex","p","splice","calculateMatch","Math","floor","random","length","isValidResult","matches","hasInvalid","find","match","undefined","values","console","log","list1","list2","output","calculateMatches","push","formatedMatches","hasValidResult","forEach","formatMatches","getValidMatch","encryptMatches","Generate","matched","className","map","Decode","React","useState","code","setCode","value","setValue","onChange","e","target","style","padding","fontSize","onClick","newValue","decrypt","enc","Utf8","App","to","path","Boolean","window","location","hostname","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.be3b3a84.chunk.js","sourcesContent":["import CryptoJS from 'crypto-js'\r\n\r\n// Note: while a cypto library is being used here, all code here is run on the frontend\r\n// and is not designed for security at all\r\n//\r\n// These functions are purely to make people names not human readable\r\n\r\nexport function encrypt(text: string, key: string): string {\r\n  return CryptoJS.AES.encrypt(text, key).toString()\r\n}\r\n\r\nexport function decrypt(text: string, key: string): string {\r\n  return CryptoJS.AES.decrypt(text, key).toString(CryptoJS.enc.Utf8)\r\n}","import { encrypt } from \"../utils/encrypt\"\r\n\r\ninterface Pairing {\r\n  person: string,\r\n  values: Array<string>\r\n}\r\n\r\ninterface FormatedPairing { \r\n  person: string,\r\n  values: string\r\n}\r\n\r\nfunction generate(people: Array<string>, doEncode: boolean): Array<FormatedPairing>{\r\n\r\n  function removeCurrentPerson (person: string, people: Array<string>): Array<string> {\r\n    const allPeople = people.slice(0) //shallow copy\r\n    const personPosition = allPeople.findIndex(p => p === person)\r\n    if(personPosition >= 0){\r\n      allPeople.splice(personPosition, 1) \r\n    }\r\n    return allPeople\r\n  }\r\n\r\n  function calculateMatch (people: Array<string>): string {\r\n    const randomPosition = Math.floor(Math.random() * people.length)\r\n    return people[randomPosition]\r\n  }\r\n\r\n  function calculateMatches (list1: Array<string>, list2: Array<string>): Array<string> {\r\n    \r\n    const match1 = calculateMatch(list1)\r\n    const match2 = calculateMatch(list2)\r\n    return [match1, match2]\r\n   \r\n  }\r\n\r\n  function encryptMatches (matches: Array<FormatedPairing>, key: string): Array<FormatedPairing> {\r\n    \r\n    let output: Array<FormatedPairing> = []\r\n    matches.forEach(match => {\r\n      output.push({person: match.person, values: encrypt(match.values, key)})\r\n    })\r\n\r\n    return output\r\n  }\r\n\r\n  function formatMatches (matches: Array<Pairing>): Array<FormatedPairing>  {\r\n\r\n    const output: Array<FormatedPairing> = []\r\n\r\n    matches.forEach(match => {\r\n      output.push({ person: match.person, values: `${match.values[0]} and ${match.values[1]}` })\r\n    })\r\n\r\n    return output\r\n  }\r\n\r\n  function isValidResult (matches: Array<Pairing>): boolean {\r\n    const hasInvalid = matches.find(match => {\r\n      return match.values[0] === undefined || match.values[1] === undefined\r\n    })\r\n    console.log('hasInvalid', hasInvalid)\r\n    return hasInvalid !== undefined\r\n  }\r\n\r\n  function match (people: Array<string>): Array<Pairing> {\r\n    const list1: Array<string> = people.slice(0)\r\n    const list2: Array<string> = people.slice(0)\r\n    const output: Array<Pairing> = []\r\n    for (const person of people){\r\n      const group1 = removeCurrentPerson(person, list1)\r\n      const group2 = removeCurrentPerson(person, list2)\r\n      const matches: Array<string> = calculateMatches(group1, group2)\r\n      list1.splice(list1.findIndex(p => p === matches[0]), 1)\r\n      list2.splice(list2.findIndex(p => p === matches[1]), 1)\r\n      output.push({person, values: matches})\r\n    }\r\n    return output\r\n  }\r\n\r\n  function getValidMatch (people: Array<string>): Array<FormatedPairing> {\r\n    let matches\r\n    let hasValidResult\r\n  \r\n    do {\r\n      matches = match(people)\r\n      hasValidResult = isValidResult(matches)\r\n    }\r\n    while (hasValidResult === true)\r\n    \r\n    return formatMatches(matches)\r\n  }\r\n\r\n  const formatedMatches = getValidMatch(people)\r\n    \r\n  return doEncode ? encryptMatches(formatedMatches, 'test') : formatedMatches \r\n\r\n}\r\n\r\nexport default generate\r\n\r\n\r\n  \r\n  ","import React from 'react';\nimport '../App.css';\nimport generate from './generate';\n\nfunction Generate() {\n  const people = [\n    \"Benjamin\",\n    \"Douglas\",\n    \"Lauretta\",\n    \"Annie\",\n    \"Kate\",\n    \"Michael\",\n    \"Steven\",\n    \"Leah\"\n  ]\n  const matched = generate(people, true)\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <ul>          \n          {matched.map(match => {\n            return (<li>{match.person} gets {match.values} </li>)\n          })}\n        </ul>\n      </header>\n      \n    </div>\n  );\n}\n\nexport default Generate;\n\n","import React from 'react';\r\nimport { decrypt } from '../utils/encrypt'\r\n\r\nfunction Decode() {\r\n  \r\n  const [ code, setCode] = React.useState(\"\")\r\n  const [ value, setValue ] = React.useState(\"Enter code above\")\r\n\r\n  function handleClick() {\r\n    const newValue = decrypt(code,'test')\r\n    setValue(newValue === \"\" ? \"Error, try again\" : newValue)\r\n  }\r\n\r\n  return (\r\n   <div className=\"App-header\">\r\n     <h1>Super Sneeky Santa</h1>\r\n     <input value={code} onChange={e => setCode(e.target.value)} style={{padding: '20px', fontSize: '30px'}} />\r\n     <button onClick={handleClick} className='button'>Decode</button>\r\n     <h2>{value}</h2>\r\n   </div>\r\n  )\r\n}\r\n\r\nexport default Decode;\r\n\r\n","import React from 'react';\nimport './App.css';\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n  Link\n} from \"react-router-dom\";\n\nimport Generate from './generate'\nimport Decode from './decode/decode'\n\nfunction App() {\n  return (\n    <Router>\n    <div>\n      <nav>\n        <ul>\n          <li>\n            <Link to=\"/\">Home</Link>\n          </li>\n          <li>\n            <Link to=\"/generate\">Generate</Link>\n          </li>\n         \n        </ul>\n      </nav>\n\n      <Switch>\n        <Route path=\"/generate\">\n          <Generate />\n        </Route>\n        <Route path=\"/\">\n          <Decode />\n        </Route>\n      </Switch>\n    </div>\n  </Router>\n  )\n}\n\nexport default App;\n\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}